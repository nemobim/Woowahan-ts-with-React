# 타입 확장하기 및 좁히기

## 1. 타입 확장하기

### 타입 확장의 장점

- 코드 중복을 줄일 수 있다!
- 어느 타입에서 확장된지 쉽게 확인할 수 있다!
- 추가적인 확장이 계속하여 가능하다!

```ts
// 기본 인터페이스
interface User {
  id: number;
  name: string;
}

// 확장 인터페이스
interface Admin extends User {
  role: "admin";
}

// 사용 예시
const user: User = { id: 1, name: "Alice" };
const admin: Admin = { id: 2, name: "Bob", role: "admin" };

// 추가 확장도 가능
interface SuperAdmin extends Admin {
  permissions: string[];
}

const superAdmin: SuperAdmin = {
  id: 3,
  name: "Charlie",
  role: "admin",
  permissions: ["manage-users", "delete-posts"],
};
```

### 유니온 타입

유니온 타입은 두 가지 이상의 타입을 조합하여 사용하는 방법

```ts
interface User {
  name: string;
  age: number;
}

interface Admin {
  name: string;
  department: "Develop" | "QA";
}

// 👇 두 인터페이스를 유니온으로 받음
const printInfo = (obj: User | Admin) => {
  console.log(obj.name); // ✅ 공통 속성(name)은 접근 가능

  // ❌ 공통되지 않은 속성은 타입 좁히기 없이 접근 불가
  // console.log(obj.age);        // 오류: 'Admin' 타입에는 'age'가 없음
  // console.log(obj.department); // 오류: 'User' 타입에는 'department'가 없음

  // ✅ 타입 좁히기를 통해 접근 가능
  if ("age" in obj) {
    console.log(`User의 나이: ${obj.age}`);
  } else {
    console.log(`Admin의 부서: ${obj.department}`);
  }
};
```

### 교차 타입

교차타입은 모든 타입의 속성을 동시에 갖는 방법

#### 기본예시

```ts
interface User {
  name: string;
  age: number;
}

interface Admin {
  role: "admin";
  department: string;
}

// 👇 두 타입을 모두 만족해야 함
type AdminUser = User & Admin;

const adminUser: AdminUser = {
  name: "Alice",
  age: 30,
  role: "admin",
  department: "QA",
};
```

#### 주의사항 1. 충돌하는 타입

속성 이름이 갖더라도 타입이 다르다면 오류가 발생함

```ts
interface A {
  value: string;
}

interface B {
  value: number;
}

type AB = A & B;

// ❌ 에러: 'value' 속성의 타입이 서로 호환되지 않음
const obj: AB = {
  value: "Hello", // string | number 둘 다 만족할 수 없음
};
```

#### 주의사항 2. 유니온 타입의 교차

양쪽 모두에 존재하는 교차 타입만 남긴다.

```ts
type A = string | number;
type B = number | boolean;

type C = A & B; // 교차 타입

// string | number
//      &
// number | boolean
// ---------------
// 결과: number
```

#### extends와 교차타입의 차이

```ts
interface A {
  value: string;
}

// extends
interface B extends A {
  value: number; // ❌ 타입 다르면 에러
  //value: string;      // ✅ 동일 타입이면 OK
}

// 교차
type C = A & { value: number }; // string & number → never
```

같은 속성을 가진 두 타입을 각각 상속과 교차를 진행한 예시이다.  
B 경우를 보면 상속받은 B는 타입이 달라서 에러를 일으킨다.  
C 경우처럼 같은이름에 다른 타입을 교차하면 에러는 발생시키지 않지만 해당하는 타입이 never로 평가된다.

## 2. 타입 좁히기 - 타입 가드

### 타입 가드에 따라 분기 처리하기

타입 가드는 런타임에 조건문을 사용하여 타입을 검사하고 타입 범위를 좁혀주는 방법이다.

### 원시 타입을 추론해야 할 때 : typeof 연산자 활용

typeof 연산자를 활용하면 원시타입에 대해 추론할 수 있다.  
다음은 typeof 연산자를 사용하여 검사할 수 있는 타입들이다.

- string
- number
- boolean
- undefined
- object
- function
- bigint
- symbol

```ts
function printValue(value: string | number) {
  if (typeof value === "string") {
    // ✅ 여기서는 string 타입으로 좁혀짐
    console.log(value.toUpperCase()); // 결과: "HELLO"
  } else {
    // ✅ 여기서는 number 타입으로 좁혀짐
    console.log(value.toFixed(2)); // 결과: "3.14"
  }
}

printValue("hello"); // 출력 → "HELLO"
printValue(3.1415); // 출력 → "3.14"
```

### 인스턴스화된 객체 타입을 판별할 때 : instanceof 연산자 활용

```ts
function ErrorMessage({ error }: { error: unknown }) {
  if (error instanceof Error) {
    // ✅ Error 타입으로 좁혀짐
    return <p>에러 발생: {error.message}</p>; // 예: "에러 발생: Network error"
  }

  return <p>알 수 없는 에러</p>;
}
```

#### 자주 쓰이는 instanceof 활용 5가지

#### 1. Error객체 검사

```ts
function ErrorMessage({ error }: { error: unknown }) {
  if (error instanceof Error) {
    return <p>에러 발생: {error.message}</p>; // 예: "Network error"
  }
  return <p>알 수 없는 에러</p>;
}
```

#### 2. File / FormData 검사 (파일 업로드)

```ts
function UploadPreview({ file }: { file: unknown }) {
  if (file instanceof File) {
    return <p>파일명: {file.name}</p>;
  } else if (file instanceof FormData) {
    return <p>FormData 객체입니다.</p>;
  }
  return <p>유효하지 않은 업로드 데이터</p>;
}
```

#### 3. Response 객체 검사 (API 응답 처리)

```ts
async function handleResponse(res: unknown) {
  if (res instanceof Response) {
    const data = await res.json();
    console.log("서버 응답:", data);
  } else {
    console.error("Response 객체가 아닙니다.");
  }
}
```

#### 4. Date 객체 검사 (날짜 유효성 검사)

```ts
function printDate(value: unknown) {
  if (value instanceof Date) {
    console.log("날짜:", value.toISOString());
  } else {
    console.log("유효하지 않은 날짜 값");
  }
}
```

#### 5. 이벤트 객체 검사 (리액트 핸들러 내부)

```ts
function handleEvent(e: unknown) {
  if (e instanceof MouseEvent) {
    console.log("마우스 클릭 좌표:", e.clientX, e.clientY);
  } else if (e instanceof KeyboardEvent) {
    console.log("입력된 키:", e.key);
  }
}
```

### 객체의 속성이 있는지 없는지 확인하는 구분 : in 연산자 활용

in은 런타임에서 안전하게 객체 타입을 구분하는 방법  
인터페이스 형태로 정의된 객체에서 자주 사용한다.

```ts
type SuccessResponse = { data: string };
type ErrorResponse = { message: string };

function RenderResult(res: SuccessResponse | ErrorResponse) {
  if ("data" in res) {
    return <p>데이터: {res.data}</p>;
  }
  return <p>에러: {res.message}</p>;
}
```

### is 연산자로 사용자 정의 타입 가드 만들어 활용

```ts
type SuccessResponse = { data: string };
type ErrorResponse = { message: string };

function isSuccess(
  res: SuccessResponse | ErrorResponse
): res is SuccessResponse {
  return "data" in res;
}

function RenderResult(res: SuccessResponse | ErrorResponse) {
  if (isSuccess(res)) {
    return <p>데이터: {res.data}</p>;
  }
  return <p>에러: {res.message}</p>;
}
```

## 3. 타입 좁히기 - 식별할 수 있는 유니온

태그된 유니온(tagged union)으로도 불리는 식별할 수 있는 유니온(Discriminated unions)은 타입 좁히기에 널리 사용되는 방식이다.

1. 개별 타입에 식별 가능한 판별자를 넣는다.
2. 유니온으로 개별 타입을 묶는다.
3. 판별자를 활용하여 타입을 좁혀 사용한다.

```ts
// 1️⃣ 개별 에러 타입 정의
interface NetworkError {
  code: 100; // 식별자
  message: string;
  status: number;
}

interface ValidationError {
  code: 200; // 식별자
  message: string;
  field: string;
}

interface AuthError {
  code: 300; // 식별자
  message: string;
  expired: boolean;
}

// 2️⃣ 유니온으로 묶기
type AppError = NetworkError | ValidationError | AuthError;

// 3️⃣ 판별자(code)를 이용한 타입 좁히기
function handleError(error: AppError) {
  switch (error.code) {
    case 100:
      console.log(
        `🌐 [NetworkError] ${error.message} (status: ${error.status})`
      );
      break;

    case 200:
      console.log(
        `⚠️ [ValidationError] ${error.field} 필드 오류 - ${error.message}`
      );
      break;

    case 300:
      console.log(
        error.expired
          ? `🔒 [AuthError] 세션 만료`
          : `🚫 [AuthError] 인증 실패 - ${error.message}`
      );
      break;
  }
}

// 4️⃣ 사용 예시
handleError({ code: 100, message: "서버 연결 실패", status: 500 });
handleError({ code: 200, message: "이메일 형식이 잘못됨", field: "email" });
handleError({ code: 300, message: "토큰 만료", expired: true });
```

## 4. Exhaustiveness Checking으로 정확한 타입 분기 유지하기

Exhaustiveness : 철저함, 완전함  
따라서 모든 케이스에 대해 철저하게 타입을 검사하는 것을 말한다.

```ts
type UIState =
  | { status: "loading" }
  | { status: "success"; data: string[] }
  | { status: "error"; message: string }
  | { status: "empty" };

function DataList({ state }: { state: UIState }) {
  switch (state.status) {
    case "loading":
      return <p>⏳ 로딩 중...</p>;

    case "success":
      return (
        <ul>
          {state.data.map((item, i) => (
            <li key={i}>{item}</li>
          ))}
        </ul>
      );

    case "error":
      return <p>❌ 에러: {state.message}</p>;

    case "empty":
      return <p>📭 데이터가 없습니다.</p>;

    default:
      // ✅ Exhaustiveness Checking
      const _exhaustiveCheck: never = state;
      console.error("처리되지 않은 상태:", _exhaustiveCheck);
      return null;
  }
}
```
