# 타입확장하기

## 타입확장

1. interface,type으로 정의하는것을 말한다.

2. extends,교차타입,유니온타입을 이용해 확장함.

### 타입확장의 장점

1. 코드의 중복을 줄일수 있다.

```ts
interface BaseMenuItem {
  itemName: string;
  itemImageUrl: string;
  stock: number;
}

// 수량정보 추가

interface CartItem extends BaseItem {
  quantity: number;
}
```

중복으로 작성하지 않고, 기존것에 extends로 확장. 코드가 간결해짐.
명시적으로도 확장되었다는게 눈에 보임.

interface대신 type을 쓴다면,

```ts
type BaseMenuItem = {
  itemName: string;
  itemImageUrl: string;
  stock: number;
};

type BaseItem = {
  quantity: number;
} & BaseMenuItem;
```

extends를 사용하지 않고, &으로 작성함.
extends 키워드는 interface 선언 시에만 직접 사용할 수 있습니다.

| 구분      | Interface  | Type       |
| --------- | ---------- | ---------- |
| 상속      | extends ✅ | extends ❌ |
| 교차      | & ✅       | & ✅       |
| 선언 병합 | 가능 ✅    | 불가능 ❌  |

2. 명시적인 코드작성
3. 확장성: 요구사항이 늘어날때마다 확장하여 정의할수 있다.

예시로,

```ts
interface EditableItem extends BaseCartItem {
  isSoldOut: boolean;
  optionGroups: SelectionOptionGroup[];
}

// 주문 가능 여부를 추가

interface EventCartItem extends BaseCartItem {
  orderable: boolean;
}

/**
 * BaseCartItem을 확장하여 만들수 있다.   
장바구니 관련한 타입들을 손쉽게 만들수 있다.   
기존 장바구니를 수정시에는 BaseCartItem을 수정하면 됨.
*/
```

### 유니온타입

```ts
type UnionType = A | B;
```

- 2개 이상의 타입을 조합하여 사용한 방법이다(합집합)
- 예제를 보면서 이해가 안된건

```ts
interface Step1 {
  b: string;
  c: string;
  z: string;
}

interface Step2 {
  a: string;
  b: string;
  c: string;
  x: string;
}

function getStep(step: Step1 | Step2) {
  return step.a; // ❌ Error!
}
```

왜 a를 못불러올까?

> 이게 합집합이면 둘다 리턴을 취할수 있지 않나?

흔히 수학적으로 아는 집합의 개념과 반대라고 생각하면 되는거 같습니다.

https://knowledge-powerful-but-harmful.tistory.com/244

AI를 통해서 정리해본 결과,

### Union Type (A | B)

### 기본 개념

여러 타입 중 하나를 가질 수 있음

- 값 할당: 합친 타입 중 아무거나 가능
- 값 사용: 넓은 타입을 더 구체적인 타입으로 좁혀나가는 과정(타입좁히기) 후 사용 (공통 속성은 타입좁히기 불필요)

### 구조적 타이핑 관점의 핵심 ⭐

"합집합을 교집합처럼 생각하라"

```ts
interface Bird {
  fly(): void;
  layEggs(): void;
}

interface Fish {
  swim(): void;
  layEggs(): void;
}

function getSmallPet(): Fish | Bird {
  // Bird 또는 Fish 반환
}

const pet = getSmallPet();
pet.layEggs(); // ✅ 공통 속성만 사용 가능 (교집합)
pet.swim(); // ❌ 에러 - 어떤 타입인지 모름
```

**왜?** TypeScript는 반환된 값이 Bird인지 Fish인지 알 수 없으므로, 양쪽 모두 가진 속성(교집합)만 안전하게 사용 가능

### 교차 타입 (A & B)

### 기본 개념

여러 타입을 모두 만족하는 타입
모든 속성을 다 가져야 함

### 구조적 타이핑 관점의 핵심 ⭐

"교집합을 합집합처럼 생각하라"

```typescript
type Person = { name: string };
type Employee = { employeeId: number };

type EmployeeDetails = Person & Employee; // 둘 다 필요 (합집합)

const employee: EmployeeDetails = {
  name: "John",
  employeeId: 12345,
};
```

**왜?** 양쪽 타입 모두에 속하려면 모든 속성(합집합)을 가져야 어느 쪽으로 간주해도 문제없음

### extends와 교차타입.

extends를 통해서도 교차 타입을 작성할 수도 있다.

위에서 설명을 해서 추가로 주의점만 설명.

```ts
interface DeliveryTip {
  tip: number;
}

interface Filter extends DeliveryTip {
  tip: string;
}

// ❌
```

extends로 타입 확장하면, 타입이 중복되면 안됨.

하지만,

```ts
type DeliveryTip = {
    tip:number;
}

type Filter = DeliveryTip{
    tip:string;
}

```

type으로 바꾸면 됨.

이때 tip속성의 타입은 string이나 number가 아닌 **never**

**왜?**

type키워드는 교차로 선언되었을시 새롭게 속성이 추가된건 속성을 미리 알 수 없기에 선언시 에러가 발생하지 않는다. tip은 같은 속성에 대해 서로 호환되 않는 타입이 선언되서 never타입이 됨.

### 타입 좁히기 - 타입 가드.
