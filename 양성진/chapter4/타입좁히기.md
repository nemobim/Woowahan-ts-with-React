# 타입좁히기

## 타입 가드

변수 또는 표현식의 타입범위를 더 작은 범위로 좁혀 나가는 과정을 말한다.
좀 더 정확하고 명시적인 타입추론이 가능하고, 복잡한 타입을 작은 범위로 축소하여 타입 안정성을 높일수 있다.

### 타입가드에 따라 분기 처리하기

> **분기 처리**
>
> 조건문과 타입가드를 활용해서 다양한 상황에 따른 다른 동작을 수행하는것을 말함.

> **타입가드**
>
> 런타임에 조건을 사용해서 타입을 검사하고 범위를 좁혀주는 기능.
> typeof,instanceof 같은 것

> **사용자 정의 타입 가드**
>
> 사용자가 직접 어떤 타입으로 값을 좁힐지 직접 지정하는 방식.

### 원시타입을 추론할때: typeof 연산자 활용하기

typeof 연산자를 이용하여 검사할수 있는 타입 목록

> string, number, boolean, undefined, symbol,bigint,object,function

```ts
function processValue(value: string | number) {
  if (typeof value === "string") {
    console.log(value.toUpperCase());
  } else {
    console.log(value.toFixed(2));
  }
}
```

### 인스턴스화된 객체 타입을 판별할때: instanceof 연산자를 활용하기

instanceof 연산자는 인스턴스화된 객체타입을 판별하는 타입 가드로 사용.

**A instanceof B 형태로 사용**

A는 타입을 검사할 대상 변수.

B는 특정 객체의 생성자가 들어감.

A의 프로토타입 체인에 생성자 B가 존재하는지 검사해서 존재하면 true 아님 false로 반환.

```ts
function handleError(error: Error | string) {
  if (error instanceof Error) {
    console.log(error.message);
  } else {
    console.log(error);
  }
}
```

### 객체의 속성이 있는지 없는지에 따른 구분: in연산자를 활용하기.

A in B의 형태로 사용.

말 그대로 B안에 A가 존재하는지를 검사한다. true or false로 반환한다.

```ts
interface Bird {
  fly(): void;
  layEggs(): void;
}

interface Fish {
  swim(): void;
  layEggs(): void;
}

function move(pet: Bird | Fish) {
  if ("fly" in pet) {
    pet.fly();
  } else {
    pet.swim();
  }
}
```

### is연산자로 사용자 정의 타입가드 만들어서 사용하기.
직접 타입 가드 함수를 만들 수 도 있다.

> A is B


A는 매개변수 이름 , B는 타입.

컴파일러에게 함수가 true을 반환하면 값이 특정 타입이다. 라고 알려주는 역할을 함.
```ts
function isString(value: unknown): value is string {
  return typeof value === 'string';
}

function process(value: unknown) {
  if (isString(value)) {
    // value는 string 타입으로 좁혀짐
    console.log(value.toUpperCase());
  }
}


  process("hello");// 정상 출력
  process(123);// 에러 발생
```
## 식별할 수 있는 유니온

종종 태그된 유니온으로 불리는 식별할 수 있는 유니온은 타입좁히기에 널리 사용되는 방식.
타입간의 구조 호환을 막기 위해 타입마다 구분할 수 있는 판별자를 달아주어 포함 관계를 제거하는 것이다.

```ts
type TextError = {
  errorCode: string;
  errorMessage: string;
};
type ToastError = {
  errorCode: string;
  errorMessage: string;
  toastDuration: number;
};
type AlertError = {
  errorCode: string;
  errorMessage: string;
  onConfirm: () => void;
};
type ErrorFeedbackType = TextError | ToastError | AlertError;
const errorArr: ErrorFeedbackType[] = [
  { errorCode: "100", errorMessage: "텍스트 에러" },
  { errorCode: "200", errorMessage: "토스트 에러", toastShowDuration: 300 },
  { errorCode: "300", errorMessage: "알러트 에러", onConfirm: () => {} },
];
```

3가지 타입의 유니온 타입인 ErrorFeedBackType의 원소를 갖는 배열 errorArr를 정의함으로 다양한 에러 객체를 관리할 수 있게 된다.

```ts
const errorArr: ErrorFeedbackType[] = [
  { errorCode: "100", errorMessage: "텍스트 에러" },
  { errorCode: "200", errorMessage: "토스트 에러", toastShowDuration: 300 },
  { errorCode: "300", errorMessage: "알러트 에러", onConfirm: () => {} },
  {
    errorCode: "300",
    errorMessage: "잘못된 에러",
    toastShowDuration: 300,
    onConfirm: () => {},
  }, //expected Error
];
```

문제: 해당 배열에 에러 타입별로 정의한 필드를 가지는 에러 객체가 포함되길 원한다고 하면, Toast의 듀레이션 필드와 Alert의 컨펌 필드를 모두 가지는 객체에 대해서는 타입 에러를 뱉어내게 됨.
하지만 코드를 작성했을때, 자바스크립트는 덕 타이핑 언어이기 때문에 별도의 타입 에러를 뱉지 않는다. 이런 상황에서 타입에러가 발생하지 않는다면, 개발과정에서 무수한 에러 객체가 생겨날 위험성이 커짐.

그래서 에러 타입을 구분할 방법이 필요.

서로 호환되지 않도록 타입들이 서로 포함관계를 가지지 않도록 정의.

```ts
type TextError = {
  errorType: "TEXT";
  errorCode: string;
  errorMessage: string;
};

type ToastError = {
  errorType: "TOAST";
  errorCode: string;
  errorMessage: string;
  toastShowDuration: number;
};

type AlertError = {
  errorType: "ALERT";
  errorCode: string;
  errorMessage: string;
  onConfirm: () => void;
};
type ErrorFeedbackType = TextError | ToastError | AlertError;
const errorArr: ErrorFeedbackType[] = [
  { errorType:'TEXT' errorCode: "100", errorMessage: "텍스트 에러" },
  { errorType:'TOAST' errorCode: "200", errorMessage: "토스트 에러", toastShowDuration: 300 },
  { errorType:'ALERT',errorCode: "300", errorMessage: "알러트 에러", onConfirm: () => {} }
  { errorType:'ALERT',errorCode: "310", errorMessage: "알러트 에러", onConfirm: () => {},
  toastShowDuration:5000, // Object literal 어쩌구저쩌구
}
];
```

직접 만들어서 본 결과

> onConfirm: () => void;
> 개체 리터럴은 알려진 속성만 지정할 수 있으며 'AlertError' 형식에 'toastShowDuration'이(가) 없습니다.ts(2353)

이러한 에러가 나옵니다. 확실히 정확하지 않는 에러 객체에 대해 타입 에러가 발생하는걸 확인할수 있습니다.

### 식별할 수 있는 유니온의 판별자 선정

식별할 수 있는 유니온을 사용시, 주의할 점이 있다.

- 유닛 타입으로 선언되어야 정상적으로 동작한다.

> ### 유닛타입이란?
>
> 다른 타입으로 쪼개지지않고, 오직 하나의 정확한 값을 가지는 타입.
>
> ex) null, undefined, 리터럴타입,true,1

void,string,number와 같은 타입은 유닛타입으로 적용되지 않는다.

공식 타입스크립트 Github 이슈탭을 살펴보면, 식별할 수 있는 유니온의 판별자로 사용할 수 있는 타입을 정의함.

- 리터럴 타입이어야한다.
- 판별자로 선정한 값에 적어도 하나 이상의 유닛 타입이 포함되어야 하며, 인스턴스화할 수 있는 타입은 포함되지 않아야한다.

https://github.com/microsoft/TypeScript/issues/30506#issuecommenW74802840

```ts
interface A {
  value: "A"; // 유닛 타입 (리터럴)
  answer: 1;
}

interface B {
  value: string; // string,number,void같은 타입은 유닛타입으로 적용되지 않음.
  answer: 2;
}
interface C {
  value: Error; // 인스턴스화가 가능한 타입.
  answer: 3;
}

type Unions = A | B | C;

function handle(param: Unions) {
  // 판별자가 value일 때

  param.answer; // 1 | 2 | 3

  // a는 리터럴타입이라 타입 좁히기가 가능.
  // 이는 string타입에 포함이 되므로 param은 A 또는 B타입으로 좁혀진다.
  if (param.value == "A") {
    param.answer; //1 | 2
  }
  // 예는 인스턴스화 되는 타입이라 좁히기가 불가능
  if (param.value instanceof Error) {
    param.answer; //1 | 2 | 3
  }
  // 판별자가 유닛 타입이므로 타입이 좁혀짐.
  if (param.answer == 1) {
    const msg = param.value.msg; // '"A"' 형식에 'msg' 속성이 없습니다.
    param.value; // a;
  }
}
```

리터럴 타입이 가능하며, 인스턴스화가 가능한것과 number,void,string같은 것들은 식별할수 있는 유니온 판별자로 설정할수 없다.

answer가 1인경우에는 A에 관련해서 타입이 좁혀지므로 len이 변수로 지정하면 가능하지만 const msg= param.value.msg로 인스턴스화된 타입값의 속성들은 끄집어낼수 없다.

## Exhaustiveness Checking으로 정확한 타입분기 유지하기.

Exhaustiveness 사전적으론 철저한 Exhaustiveness Checking은 철저한 체킹

철저하하게 모든 케이스에 대해 타입을 검사하는것을 말함.

타입 좁히기에 사용되는 패러다임중 하나임.
