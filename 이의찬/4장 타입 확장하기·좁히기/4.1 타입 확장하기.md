## 1. 타입 확장하기

기존 타입을 사용해서 새로운 타입을 정의하는 것.

### 유니온 타입

- 2개 이상의 타입을 조합해서 사용. **OR**
- type은 `|`기호로 표현

**유니온 타입으로 선언된 값**은 유니온 타입에 **포함된 모든 타입이 공통으로 갖고 있는 속성**에만 접근 가능

```tsx
interface CookingStep {
	orderld： string;
	price： number;
}

interface Deliverystep {
	orderld： string;
	time： number;
	distance： string;
}

// step이라는 유니온 타입은 CookingStep 또는 DeliveryStep 타입에 해당
// CookingStep이면서 동시에 DeliveryStep인 것은 아니다!
function getDeliveryDistance(step： CookingStep | Deliverystep) {
	return step.distance;
	// ■ Property 'distance' does not exist on type 'CookingStep | Deliverystep'
	// ■ Property 'distance' does not exist on type 'CookingStep'
}

```

### 교차타입

- 2개 이상의 타입을 조합해서 사용. AND
- type에서 `&`기호로 표현

```tsx
// BaedalProgress는 CookingStep과 Deliverystep를 합쳐 모든 속성을 가진 타입
type BaedalProgress = CookingStep & Deliverystep;
```

> → 교집합이라매;; 이건 합집합 아닌가요? 왜 이렇게 되나요?

타입스크립트의 타입은 속성의 집합이 아니라 값의 집합이기 때문!
> 

```tsx
/* 배달 팁 */
interface DeliveryTip {
	tip： string;
}
/* 별점 */
interface StarRating {
	rate： number;
}
/* 주문 필터 */
type Filter = DeliveryTip & StarRating;

const filter： Filter = {
	tip： ”1000원 이하",
	rate： 4,
}；
```

### extends와 교차타입

extends 키워드를 사용해서 교차 타입을 작성할 수 있다.

```tsx
/**
* 메뉴 요소 타입
* 메뉴 이름, 이미지, 할인율, 재고 정보를 담고 있다
**/
interface BaseMenuitem {
	itemName： string | null;
	itemlmageUrl： string ] null;
	itemDiscountAmount： number;
	stock： number | null;
}

/**
* 장바구니 요소 타입
* 메뉴 타입을 상속 + 수량 정보 추가
**/

interface BaseCartltem extends BaseMenuitem {
	quantity： number;
}

// type으로 하면
type BaseMenuitem = {
	itemName： string | null;
	itemlmageUrl： string | null;
	itemDiscountAmount ： number;
	stock： number | null;
}；

type BaseCartitem = {
	quantity： number;
} & BaseMenuitem;
```

둘의 차이점은 같은 속성에 대해서 서로 다른 타입을 명시했을 때다.

interface의 경우 error가 발생하지만, type의 경우 해당 속성의 type이 never로 변경된다.

```tsx
/* interface의 경우 */
interface DeliveryTip {
	tip： number;
}

interface Filter extends DeliveryTip {
	tip： string;
	// Interface ’Filter' incorrectly extends interface 'DeliveryTip'
	// Types of property 'tip' are incompatible
	// Type 'string' is not assignable to type 'number'
}

/* type의 경우 */
type DeliveryTip = {
	tip： number;
}；

type Filter = DeliveryTip & {
	tip： string;
}；
// tip은 never 타입!
```

### 배민 메뉴 시스템에 타입 확장 적용하기

![image.png](attachment:d55459a6-27ce-4bab-b701-e7169b89186c:image.png)

일단 아래와 같은 interface를 기반으로 다음 코드가 있다고 하자.

```tsx
interface Menu {
	name： string;
	image： string;
}

function MainMenu() {
	// Menu 타입을 원소로 갖는 배열
	const menuList： Menu[] = [{name： "1인분", image： "1인분.png"}, ...]
	return (
		<ul>
			{menuList.map((menu) => (
				<li>
					<img src={menu.image} />
					<span>{menu .name}</span>
				</li>
			))}
		</ul>
	)
}
```

다음 요구 사항이 추가되었을 때, 어떻게 요구 사항을 만족하는 타입을 작성할 것인가?

1. 특정 메뉴를 길게 누르면 gif 파일이 재생되어야 한다.
2. 특정 메뉴는 이미지 대신 별도의 텍스트만 노출되어야 한다.

```tsx
/* 서버 응답 값 */
const menuList = [
	{ name： "찜", image： "찜.png" },
	{ name： "찌개", image： "찌개.png" },
	{ name： "회", image： "회.png" },
]；

const specialMenuList = [
	{ name： "돈까스", image： "돈까스.png", gif： "돈까스.gif" },
	{ name： "피자", image： "피자.png", gif： "피자.gif" },
]；

const packageMenuList = [
{ name： "1인분", image： "1 인분.png", text： "1 인 가구 맞춤형" },
{ name： "족발", image： "족발.png", text： "오늘은 족발로 결정" },
```

### 방법

1. **타입 내에서 속성을 추가하기**

```tsx
interface Menu {
	name： string;
	image： string;
	gif?： string; // 요구 사항 1 
	text?: string; // 요구 사항 2
}

// specialMenuList 배열의 원소가 각 속성에 접근한다면?
specialMenuList.map((menu) => menu.text); 
// TypeError： Cannot read properties of undefined
```

specialMenuList는 Menu 타입의 원소를 갖기 때문에 text 속성에도 접근할 수 있다. 하지만 specialMenuList 배열의 모든 원소가 text라는 속성을 가지고 있지는 않다.

1. **타입 확장 활용**

```tsx
interface Menu {
	name： string;
	image： string;
}

interface SpecialMenu extends Menu {
	gif： string;
}
interface PackageMenu extends Menu {
	text： string;
}
```

각 배열의 타입을 확장할 타입에 맞게 명확히 구현될 수 있으며, 이를 바탕으로 specialMenuList 배열의 원소 내 속성에 동일하게 접근한다고 해도 미리 에러가 출력되는 것을 확인할 수 있다.

**결론!** 

주어진 타입에 무분별하게 속성을 추가하는 것보다 타입을 확장해서 사용하는 것이 좋다.

1. 적절한 네이밍을 통해서 의도를 명확히 표현하고
2. 코드 작성 단계에서 예기치 못한 버그도 예방할 수 있다.