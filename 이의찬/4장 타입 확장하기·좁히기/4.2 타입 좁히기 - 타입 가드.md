## 2. 타입 좁히기 - 타입 가드

### 타입 가드에 따라 분기 처리하기

- 런타임에 조건문을 사용해 타입을 검사하고, 타입 범위를 좁혀주는 기능

### 원시 타입을 추론할 때: **typeof** 연산자 활용하기

`typeof`를 사용하면 원시 타입에 대해서 추론이 가능하다. 하지만 null, 배열 타입등이 `object`로 출력되기에 복잡한 타입 검증에는 한계가 있다.

### 인스턴스화된 객체 타입을 판별할 때: **instanceof** 연산자 활용하기

`instanceof` 연산자는 인스턴스화된 객체 타입을 판별하는 타입 가드로 사용할 수 있다.

A `instanceof` B 형태로 사용하며 A에는 타입을 검사할 대상 변수, B에는 특정 객체의 생성자가 들어간다.

A의 프로토타입 체인에 생성자 B가 존재하는지를 검사해서 여부에 따라 `true` 와 `false`를 반환한다.

### 객체의 속성이 있는지 없는지에 따른 구분: **in** 연산자 활용하기

A `in` B의 형태로 사용하는데 이름 그대로 A라는 속성이 B 객체에 존재하는지 확인한 다음에 `true` 또는 `faIse` 를 반환한다.

```tsx
interface BasicNoticeDialogProps {
	noticeTitle： string;
	noticeBody： string;
}
interface NoticeDialogWithCookieProps extends BasicNoticeDialogProps {
	cookieKey： string;
	noForADay?： boolean;
	neverAgain?： boolean;
}

export type NoticeDialogProps =
| BasicNoticeDialogProps
| NoticeDialogWithCookieProps；

// NoticeDialog의 Props에 따라 다른 컴포넌트를 랜더링하도록 할 수 있다.
const NoticeDialog：React.FC<NoticeDialogProps> = (props) => {
	if ("cookieKey" in props) return <NoticeDialogWithCookie {...props} />;
	return <NoticeDialogBase {...props} />;
};
```

### **is 연**산자로 사용자 정의 타입 가드 만들어 활용하기

직접 타입 가드 함수를 만들어서 사용하는 방식으로 A `is` B 형식으로 작성한다. 여기서 A는 매개변수 이름이고 B는 타입이다.

```tsx
// string 타입의 매개변수가 destinationCodeList 배열의 원소 중 하나인지 검사해서 boolean을 반환
const isDestinationCode = (x： string)： x is Destinationcode => destinationCodeList.includes(x);
```