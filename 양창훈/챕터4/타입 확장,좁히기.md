# 타입확장하기
타입 확장은 기존 타입을 사용해서 새로운 타입을 정의하는 것을 말한다

기본적으로 interface와 type 키워드를 사용해서 타입을 정의하고 **extends, 교차 타입, 유니온 타입**을 사용하여 타입을 확장한다.

타입확장의 장점과 각각 차이를 알아본다

타입확장시 코드 중복을 줄일 수 있다.

```ts
// 메뉴 요소 타입
// 메뉴 이름,이미지,할인율,재고 정보를 담고 있다.
interface BaseMenuItem {
  itemName: string | null;
  itemImageUrl: string | null;
  itemDiscountAmount: number;
  stock: number | null;
}
// 장바구니 요소타입
// 메뉴 타입에 수량 정보가 추가 됨

interface BaseCartItem extends BaseMenuItem {
  quantity: number;
}

}
위처럼 BaseMenuItem 타입을 extends하면 어떤 변화가 있을까?

BaseCartItem 타입을 사용시 quantity를 포함한 나머지 BaseMenuItem의 속성도 필수적으로 사용해야할까?

그럼 애초에 BaseMenuItem에 quantity를 넣지 않는 이유를 뭘까? 필요없는 상황이라면 optional 문법을 적용하면 되지 않는가 ?



BaseCartItem은 BaseMenuItem의 모든 속성을 포함하면서 quantity가 추가된 타입이에요.

```ts
const item: BaseCartItem = {
  itemName: "콜라",
  itemImageUrl: "/images/cola.png",
  itemDiscountAmount: 100,
  stock: 50,
  quantity: 2, // 추가된 속성
};
```


🧩 2️⃣ 그럼 왜 quantity를 BaseMenuItem 안에 넣지 않을까?

이건 역할 분리 (Separation of Concerns) 때문이에요.

BaseMenuItem: “상품” 자체를 표현하는 타입
(DB나 API에서 메뉴 목록을 받을 때 사용)

BaseCartItem: “장바구니에 담긴 상품”을 표현하는 타입
(상품 + 수량)



다시 말해 장바구니 요소는 메뉴 요소가 가지는 모든 타입이 필요하다.
하지만 BaseMenuItem에 있는 속성을 중복해서 작성하지 않고 확장 extends를 활용하여 타입을 정의함으로써 중복된 코드를 줄일 수 있따.
interface 대신 type을 쓴다면 아래와 같이 코드를 작성하면 된다.

```ts
type BaseMenuItem = {
  itemName: string | null;
  itemImageUrl: string | null;
  itemDiscountAmount: number;
  stock: number | null;
}

type BaseCartItem = {
  quantity: number;
} && BaseMenuItem;

```

앞의 BaeCartItem을 활용하면 요구사항이 늘어날 때마다 새로운 CartItem 타입을 확장하여 정의할 수 잇다.

```ts
// 수정할 수 있는 장바구니 요소 타입
// 품절 여부, 수정할 수 있는 옵션 배열 정보 추가
interface EditableCartItem extends BaseCartItem{
  isSoldOut: boolean;
  optionGroups: SelectableOptionGroup[];
}

```


## 유니온 타입

유니온 타입으로 선언된 값은 유니온 타입에 포함된 모든 타입이 공통으로 갖고 있는 속성에만 접근할 수 잇다.


```ts
interface CookingStep {
  orderId: string;
  price: number;
}

interface DeliveryStep {
  orderId: string;
  time: number;
  distance: string;
}

function getDeliveryDistance(step: CookingStep | DeliveryStep){
  return step.distance;
// 에러 distance는 CookingStep과 DeliveryStep 타입의 공통된 속성이 아니기 때문에
}

const cookDeliverEx: CookingStep | DeliveryStep = {distance: "1000미터",price: 3000}
const cookDistancec = cookDeliveryEx.distance 는 에러일까 아닐까>?
// 에러 쓰고싶으면 타입좁히기 쓰셈
```



## extends와 교차타입

```ts
interface DeliveryTip{
  tip: number;
}
interface Filter extends Delivery{
  tip: string;
}
// 에러

type DeliveryTip = {
  tip: number;
}

type Filter = DeliveryTip & {
  tip: string;
}
은 에러 안발생
```
이때 Filter에서 tip의 속성은 number일까 string일까 정답은 never이다.

type 키워드는 교차 타입으로 선언되었을때 새롭게 추가되는 속성에 대해 미리 알 수 없기때문에 선언 시 에러가 발생하지 않는다.
tip이라는 같은 속성에 대해 서로 호환되지 않는 타입이 선언되어 결국 never타입이 된다.

type의 교차(&)는 속성 충돌 시 미리 에러를 내지 않고,
서로 호환되지 않으면 자동으로 never로 평가된다.
이는 interface의 명시적 상속과 가장 큰 차이점이다. 라네요..

아 정리한거 저장못해서 다 날아감
# 타입 좁히기-타입 가드

## 원시 타입 추론할대는 typeof 연산자 활용

typeof 연산자를 사용하여 검사할 수 있는 타입목록
**string, number, boolean, undefiend, object, function, bigint, symbol**

```ts
const replaceHyphenL (date: stirng | Date) => stirng| Date = (date) =>{
  if (typeof date === "string" {
    return date.replace(/-/g,"/")
  }
  return date;
}
```
Date는 replace메서드를 사용하지 못한다. 
따라서 위처럼 typeof연산자를 활용해 string타입을 추론하여 안전하게 메서드를 사용하거나 안하거나하여 타입을 좁힌다.


## 인스턴스화된 객체 타입을 판별할때는 instanceof 연산자 활용

A instanceof B 
A에는 타입을 검사할 대상 변수, B에는 특정 개체의 생성자
A프로토타입 체인에 생성자 B가 존재하는지를 검사해서 존재한다면 true 아니면 false

```ts
return selected instanceof Date
  ? {start:seleceted,end:selecetd}
  : seleceted;
```

이 코드에서 instanceof를 쓴 이유는 typeof로는 Date 객체를 판별할 수 없기 때문!

## 객체의 속성이 있는지 없는지에 따라 구분 in 연산자 활용
in 연산자는 객체에 속성이 있는지 확인한 다음에 true 또는 false를 반환

```ts
const NoticeDialog: React.FC<NoticeDialogProps> = (props) => {
  if ("cookieKey" in props) return <NoticeDialogWithCookie {..props} /> ;
  return <NoticeDialogBase {...props}/>;
}
```
위 코드도 typeof 나 instanceof 쓰면 안되나 ?

이건 객체 속성 기반 타입 구분이기 때문

props는 여러 형태(예: NoticeDialogBaseProps | NoticeDialogWithCookieProps) 중 하나


# 타입좁히기- 식별할 수 있는 유니온

## 식별할 수 있는 유니온

식별자,판별자를 넣어 해당 타입의 속성을 판별한다

```ts
type Shape =
  | { kind: "circle"; radius: number }
  | { kind: "square"; sideLength: number };
```
타입 shape는 kind의 값에 따라 속성이 정해진다

```ts
const shapeEx: Shape = {kind:"circle", sideLength: 10} //에러
```
식별자 circle에 따른 속성이 달라 에러가 발생한다

위 식별자로 타입을 좁힐 수 있다

```ts
function getArea(shape: Shape) {
  if (shape.kind === "circle") {
    return Math.PI * shape.radius ** 2;
  } else {
    return shape.sideLength ** 2;
  }
}
```
