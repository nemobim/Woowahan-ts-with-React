## API 에러 처리 가이드
프론트엔드 개발에서 API를 호출하다 보면 다양한 에러 상황을 마주하게 됩니다. 인증이 되지 않은 사용자(401), 존재하지 않는 리소스를 요청한 경우(404), 서버 내부 에러(500), 또는 CORS 정책 위반 등 여러 형태의 에러가 발생할 수 있습니다.
이러한 에러에 대해 명확하게 처리하는 코드를 작성하면 유지보수가 쉬워지고 사용자에게도 어떤 문제가 발생했는지 더 정확하게 알릴 수 있습니다.

### 1. 타입 가드를 활용한 에러 처리
`Axios` 라이브러리는 요청 중 발생할 수 있는 에러를 구분할 수 있도록 `isAxiosError`라는 타입 가드 함수를 제공합니다.
> **타입 가드(Type Guard)** 란
> 자바스크립트의 런타임 값을 검사해 타입스크립트 컴파일러에게 특정 타입임을 보장하는 조건을 제공한다.

예를 들어, 다음과 같이 서버에서 전달하는 에러 응답의 타입을 정의할 수 있습니다:
```tsx
interface ErrorResponse {
  status: string;
  serverDateTime: string;
  errorCode: string;
  errorMessage: string;
}
```
이 타입을 바탕으로 우리가 만든 isServerError라는 타입 가드 함수는 AxiosError<ErrorResponse> 타입인지 확인합니다.
```
function isServerError(error: unknown): error is AxiosError<ErrorResponse> {
  return axios.isAxiosError(error);
}
```
이제 catch 문에서 isServerError로 구분하여 처리할 수 있습니다.
```tsx
try {
  await axios.post("/orders/delete", { id });
  alert("주문 내역이 삭제되었습니다.");
} catch (error) {
  if (isServerError(error)) {
    setErrorMessage(error.response.data.errorMessage);
  } else {
    setErrorMessage("알 수 없는 오류가 발생했습니다.");
  }
}
```
이처럼 에러를 명확히 구분하면 코드 가독성이 좋아지고 사용자에게도 더 나은 피드백을 제공할 수 있습니다.

### 2. 에러 서브클래싱으로 에러 유형 분리하기
서버 에러 외에도 인증 실패, 네트워크 끊김, 요청 시간 초과 등 다양한 에러가 발생할 수 있습니다. 
이러한 에러들을 각각 다른 에러 클래스로 분리하면 처리 로직을 더 명확히 만들 수 있습니다.
> **서브클래싱(Subclassing)** 이란
> 기존 클래스(부모 클래스)를 확장하여 새로운 클래스(자식 클래스)를 만드는 방식입니다.
> 각각의 에러 상황을 별도의 클래스로 만들면, 에러를 더 명확하게 분류하고 처리할 수 있습니다.

```tsx
class OrderHttpError extends Error {
  private readonly privateResponse: AxiosResponse<ErrorResponse> | undefined;

  constructor(message?: string, response?: AxiosResponse<ErrorResponse>) {
    super(message);
    this.name = "OrderHttpError";
    this.privateResponse = response;
  }

  get response(): AxiosResponse<ErrorResponse> | undefined {
    return this.privateResponse;
  }
}

class NetworkError extends Error {
  constructor(message = "") {
    super(message);
    this.name = "NetworkError";
  }
}

class UnauthorizedError extends Error {
  constructor(message: string, response?: AxiosResponse<ErrorResponse>) {
    super(message);
    this.name = "UnauthorizedError";
  }
}
```

### 3. Axios 인터셉터에서 에러 분류하기
Axios의 응답 인터셉터를 활용하면 에러 발생 시 공통 처리 로직을 적용할 수 있습니다. 
예를 들어, 에러 상황에 따라 위에서 정의한 서브클래스 에러로 변환할 수 있습니다.
```tsx
import axios, { AxiosError, HttpStatusCode } from "axios";

const httpErrorHandler = (error: AxiosError<ErrorResponse> | Error): Promise<never> => {
  if (axios.isAxiosError(error)) {
    const { response, code, message } = error;

    if (code === "ECONNABORTED") {
      return Promise.reject(new TimeoutError());
    }

    if (message === "Network Error") {
      return Promise.reject(new NetworkError());
    }

    switch (response?.status) {
      case HttpStatusCode.Unauthorized:
        return Promise.reject(
          new UnauthorizedError(response.data.errorMessage, response)
        );
      default:
        return Promise.reject(
          new OrderHttpError(response?.data?.errorMessage ?? "서버 오류", response)
        );
    }
  }

  return Promise.reject(error);
};

axios.interceptors.response.use(
  (res) => res,
  httpErrorHandler
);
```
인터셉터에 이 핸들러를 연결하면 모든 요청에 자동으로 적용됩니다:
```tsx
orderApiRequester.interceptors.response.use(
  (response) => response,
  httpErrorHandler
);
```
### 4. 공통 에러 처리 함수 작성하기
이제 분류된 에러를 어떻게 처리할지 정하는 공통 함수를 만들 수 있습니다
```tsx
const defaultHttpErrorMessage = "문제가 발생했습니다. 잠시 후 다시 시도해주세요.";

const showAlert = (message: string) => {
  console.log("알림:", message); // 실제로는 모달, Toast, 상태관리 등 활용
};

const onActionError = (error: unknown) => {
  if (error instanceof UnauthorizedError) {
    // 인증 실패 → 로그인 페이지로 이동
    window.location.href = `/login?targetUrl=${encodeURIComponent(window.location.href)}`;
  } else if (error instanceof NetworkError) {
    showAlert("네트워크 연결이 원활하지 않습니다. 다시 시도해주세요.");
  } else if (error instanceof OrderHttpError) {
    showAlert(error.message);
  } else if (error instanceof TimeoutError) {
    showAlert("요청 시간이 초과되었습니다. 다시 시도해주세요.");
  } else if (error instanceof Error) {
    showAlert(error.message);
  } else {
    showAlert(defaultHttpErrorMessage);
  }
};
```

### 5. 에러 바운더리 활용하기 (React 전용)
React에서는 컴포넌트 트리에서 발생하는 에러를 잡아주는 에러 바운더리를 활용할 수 있습니다. 
예기치 못한 에러가 발생해도 앱 전체가 멈추지 않고, 사용자에게 에러 페이지를 보여줄 수 있습니다.
```tsx
import { ErrorBoundary } from "react-error-boundary";

const ErrorFallback = ({ error }: { error: Error }) => (
  <div>
    <h2>문제가 발생했습니다.</h2>
    <p>{error.message}</p>
    <button onClick={() => location.reload()}>다시 시도하기</button>
  </div>
);

const App = () => (
  <ErrorBoundary FallbackComponent={ErrorFallback}>
    <OrderHistoryPage />
  </ErrorBoundary>
);

```
### 6. 상태 관리 도구와 함께 에러 처리하기
상태 관리 라이브러리에서도 에러 처리를 통합하면 전역 상태에 따라 알림이나 오류 화면을 제어할 수 있습니다. 
예를 들어, React Query, Recoil, Zustand 등의 상태 관리 도구에 에러 핸들러를 연결하면 됩니다.

### 7. API 모킹 (Mocking)으로 개발 환경 안정화하기
서버 API가 아직 준비되지 않았거나 개발 중 서버 상태가 불안정할 경우 API 모킹을 통해 프론트엔드 개발을 계속할 수 있습니다.

#### 1) JSON 파일 불러오기
간단한 데이터가 필요한 경우 JSON 파일을 직접 불러옵니다.
```tsx
// mock/service.ts
const SERVICES = [
  { id: 0, name: "배달의민족" },
  { id: 1, name: "만화경" },
];

export default SERVICES;
```
```tsx
// api.ts
const getServices = ApiRequester.get("/mock/service.ts");
```
#### 2) NextApiHandler로 모킹 API 만들기
Next.js를 사용하는 경우 NextApiHandler로 간단한 API 응답을 구현할 수 있습니다.
```tsx
// pages/api/mock/brand.ts
import { NextApiHandler } from "next";

const BRANDS = [
  { id: 1, label: "배민스토어" },
  { id: 2, label: "비마트" },
];

const handler: NextApiHandler = (req, res) => {
  res.status(200).json(BRANDS);
};

export default handler;
```
#### 3) 조건에 따라 목업 함수와 실제 요청 분기하기
개발 중에는 조건에 따라 실제 요청 대신 모킹 데이터를 사용할 수 있습니다.
```tsx
import axios from "axios";
import AxiosMockAdapter from "axios-mock-adapter";

const mock = new AxiosMockAdapter(axios, { delayResponse: 500 });

mock.onGet("/brands").reply(200, {
  status: "SUCCESS",
  data: [
    { id: 1, label: "배민스토어" },
    { id: 2, label: "비마트" },
  ],
});

```
> 개발 환경에서만 모킹을 적용하고 싶다면 process.env.NODE_ENV로 분기 처리
