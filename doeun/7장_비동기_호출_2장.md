## 왜 에러 처리를 해야 할까?
API 호출이 실패했을 때 적절한 안내를 하지 않으면 사용자는 시스템에 문제가 생겼는지조차 알 수 없습니다. 또한 개발자 입장에서도 디버깅이 어려워집니다.

에러 상황을 명확하게 구분해야 유지보수도 훨씬 쉬워집니다.

예를 들어:
- 인증이 만료되었을 땐 로그인 페이지로 이동
- 네트워크가 끊기면 다시 시도하라는 안내
- 서버가 에러 메시지를 주면 그대로 사용자에게 보여주기

이런 처리들이 필요합니다.

## API 에러 처리 가이드
프론트엔드 개발에서 API를 호출하다 보면 다양한 에러 상황을 마주하게 됩니다. 인증이 되지 않은 사용자(401), 존재하지 않는 리소스를 요청한 경우(404), 서버 내부 에러(500), 또는 CORS 정책 위반 등 여러 형태의 에러가 발생할 수 있습니다.
이러한 에러에 대해 명확하게 처리하는 코드를 작성하면 유지보수가 쉬워지고 사용자에게도 어떤 문제가 발생했는지 더 정확하게 알릴 수 있습니다.

### 1. 타입 가드를 활용한 에러 처리

먼저 백엔드에서 에러 응답으로 보내주는 JSON 구조를 타입으로 정의합니다.
```tsx
// 서버 에러 응답 타입 예시
interface ErrorResponse {
  status: string;              // ex) "ERROR"
  serverDateTime: string;      // 서버 시간
  errorCode: string;           // ex) "USER_NOT_FOUND"
  errorMessage: string;        // 사용자에게 보여줄 메시지
}
```
서버와 협업할 때 위 구조가 다를 수도 있으니, 실제 백엔드와 응답 형태를 맞춰야 합니다.

`Axios`를 쓰면 catch 블록에서 error는 보통 unknown 타입입니다.
Axios가 만든 에러인지, 일반 자바스크립트 에러인지 구분하려면 타입 가드 함수를 만들어야 합니다.

> **타입 가드(Type Guard)** 란
> 자바스크립트의 런타임 값을 검사해 타입스크립트 컴파일러에게 특정 타입임을 보장하는 조건을 제공한다.

이 타입을 바탕으로 우리가 만든 isServerError라는 타입 가드 함수는 AxiosError<ErrorResponse> 타입인지 확인합니다.
```
import { AxiosError } from "axios";

// Axios 에러이면서, 서버가 응답한 errorMessage가 있는지 확인
function isServerError(error: unknown): error is AxiosError<ErrorResponse> {
  return (
    axios.isAxiosError(error) &&
    !!error.response?.data?.errorMessage
  );
}
```
이제 catch 블록에서 안전하게 응답 메시지를 꺼낼 수 있습니다
```tsx
try {
  await axios.post("/orders/delete", { id });
  alert("주문 내역이 삭제되었습니다.");
} catch (error) {
  if (isServerError(error)) {
    setErrorMessage(error.response.data.errorMessage);
  } else {
    setErrorMessage("알 수 없는 오류가 발생했습니다.");
  }
}
```
이처럼 에러를 명확히 구분하면 코드 가독성이 좋아지고 사용자에게도 더 나은 피드백을 제공할 수 있습니다.

### 2. 에러 서브클래싱으로 에러 유형 분리하기
서버 에러 외에도 인증 실패, 네트워크 끊김, 요청 시간 초과 등 다양한 에러가 발생할 수 있습니다. 
에러 상황을 더 세분화해서 처리하려면 각 에러를 클래스로 만들어 구분할 수 있습니다.
> 이걸 서브클래싱(subclassing) 이라고 합니다.
> 기존 클래스(부모 클래스)를 확장하여 새로운 클래스(자식 클래스)를 만드는 방식입니다.
> Error 클래스를 상속해서 우리가 원하는 에러 타입을 만드는 겁니다.

```tsx
class OrderHttpError extends Error {
  constructor(
    public readonly message: string,
    public readonly response?: AxiosResponse<ErrorResponse>
  ) {
    super(message);
    this.name = "OrderHttpError";
  }
}

class NetworkError extends Error {
  constructor(message = "네트워크 오류가 발생했습니다.") {
    super(message);
    this.name = "NetworkError";
  }
}

class UnauthorizedError extends Error {
  constructor(
    public readonly message: string,
    public readonly response?: AxiosResponse<ErrorResponse>
  ) {
    super(message);
    this.name = "UnauthorizedError";
  }
}

class TimeoutError extends Error {
  constructor(message = "요청 시간이 초과되었습니다.") {
    super(message);
    this.name = "TimeoutError";
  }
}
```

### 3. Axios 인터셉터에서 에러 분류하기
매번 try-catch에서 똑같은 코드 쓰기 번거롭습니다.
Axios 인터셉터를 사용하면 공통 로직을 한 곳에서 처리할 수 있습니다.
```tsx
import axios, { AxiosError, HttpStatusCode } from "axios";

const httpErrorHandler = (error: AxiosError<ErrorResponse> | Error): Promise<never> => {
  if (axios.isAxiosError(error)) {
    const { response, code, message } = error;

    if (code === "ECONNABORTED") {
      return Promise.reject(new TimeoutError());
    }

    if (message === "Network Error") {
      return Promise.reject(new NetworkError());
    }

    switch (response?.status) {
      case HttpStatusCode.Unauthorized:
        return Promise.reject(
          new UnauthorizedError(response.data.errorMessage, response)
        );
      default:
        return Promise.reject(
          new OrderHttpError(response?.data?.errorMessage ?? "서버 오류", response)
        );
    }
  }

  return Promise.reject(error);
};

// 모든 요청에 인터셉터 적용
axios.interceptors.response.use(
  (res) => res,
  httpErrorHandler
);
```
인터셉터에 이 핸들러를 연결하면 모든 요청에 자동으로 적용됩니다:
```tsx
orderApiRequester.interceptors.response.use(
  (response) => response,
  httpErrorHandler
);
```
### 4. 공통 에러 처리 함수 작성하기
이제 분류된 에러를 어떻게 처리할지 정하는 공통 함수를 만들 수 있습니다
```tsx
const defaultHttpErrorMessage = "문제가 발생했습니다. 잠시 후 다시 시도해주세요.";

const showAlert = (message: string) => {
  console.log("알림:", message); // 실제로는 모달, Toast, 상태관리 등 활용
};

const onActionError = (error: unknown) => {
  if (error instanceof UnauthorizedError) {
    // 인증 실패 → 로그인 페이지로 이동
    window.location.href = `/login?targetUrl=${encodeURIComponent(window.location.href)}`;
  } else if (error instanceof NetworkError) {
    showAlert("네트워크 연결이 원활하지 않습니다. 다시 시도해주세요.");
  } else if (error instanceof OrderHttpError) {
    showAlert(error.message);
  } else if (error instanceof TimeoutError) {
    showAlert("요청 시간이 초과되었습니다. 다시 시도해주세요.");
  } else if (error instanceof Error) {
    showAlert(error.message);
  } else {
    showAlert(defaultHttpErrorMessage);
  }
};
```
```tsx
const deleteOrder = async (id: string) => {
  try {
    await axios.post("/orders/delete", { id });
    showAlert("주문이 성공적으로 삭제되었습니다.");
  } catch (error) {
    onActionError(error);
  }
};
```
### 5. 에러 바운더리 활용하기 (React 전용)
React에서는 컴포넌트 트리에서 발생하는 에러를 잡아주는 에러 바운더리를 활용할 수 있습니다. ErrorBoundary를 사용하면 특정 컴포넌트의 에러만 잡고 앱은 계속 동작할 수 있습니다.
```tsx
import { ErrorBoundary } from "react-error-boundary";

const ErrorFallback = ({ error }: { error: Error }) => (
  <div>
    <h2>문제가 발생했습니다.</h2>
    <p>{error.message}</p>
    <button onClick={() => location.reload()}>다시 시도하기</button>
  </div>
);

const App = () => (
  <ErrorBoundary FallbackComponent={ErrorFallback}>
    <OrderHistoryPage />
  </ErrorBoundary>
);

```
### 6. API 목업(Mock)으로 서버 없이 개발하기
서버 API가 아직 준비되지 않았거나 개발 중 서버 상태가 불안정할 경우 Mock 데이터를 활용하면 서버 없이도 작업할 수 있습니다.

#### 1) JSON 파일 불러오기
간단한 데이터가 필요한 경우 JSON 파일을 직접 불러옵니다.
```tsx
// mock/service.ts
const SERVICES = [
  { id: 0, name: "배달의민족" },
  { id: 1, name: "만화경" },
];

export default SERVICES;
```
```tsx
// api.ts
const getServices = ApiRequester.get("/mock/service.ts");
```
#### 2) NextApiHandler로 모킹 API 만들기
Next.js를 사용하는 경우 NextApiHandler로 간단한 API 응답을 구현할 수 있습니다.
```tsx
// pages/api/mock/brand.ts
import { NextApiHandler } from "next";

const BRANDS = [
  { id: 1, label: "배민스토어" },
  { id: 2, label: "비마트" },
];

const handler: NextApiHandler = (req, res) => {
  res.status(200).json(BRANDS);
};

export default handler;
```
#### 3) 조건에 따라 목업 함수와 실제 요청 분기하기
개발 중에는 조건에 따라 실제 요청 대신 모킹 데이터를 사용할 수 있습니다.
> 개발 환경에서만 모킹을 적용하고 싶다면 process.env.NODE_ENV로 분기 처리

#### 4) axios-mock-adapter로 완전한 모킹
```tsx
import axios from "axios";
import AxiosMockAdapter from "axios-mock-adapter";

const mock = new AxiosMockAdapter(axios, { delayResponse: 500 });

mock.onGet("/brands").reply(200, {
  status: "SUCCESS",
  data: [
    { id: 1, label: "배민스토어" },
    { id: 2, label: "비마트" },
  ],
});
```
