# 7장 비동기 호출
> ✅ 비동기를 위해 필요한 정보
- 현재 비동기 동작이 어떤 상태인가
- 비동기 동작을 위해 필요한 정보가 무엇인가
- 요청이 성공했다면 받아온 정보를 어떻게 저장하고 관리할 것인가
- 요청이 실패했다면 실패에 대한 정보를 어떻게 예측할 것인가
- 비동기 요청에 대한 코드를 쉽게 유지보수할 수 있도록 어떻게 구조화하고 관리할 것인가

## 1. API 요청
컴포넌트 안에서 API를 직접 호출
```tsx
import React, { useEffect, useState } from "react";

const CartBadge: React.FC = () => {
  const [cartCount, setCartCount] = useState(0);

  useEffect(() => {
    fetch("https://api.baemin.com/cart")
      .then((response) => response.json())
      .then(({ cartItem }) => {
        setCartCount(cartItem.length);
      });
  }, []);

  return <>{/*  cartCount 상태를 이용하여 컴포넌트 렌더링 */}</>;
};
```
이 방법은 간단하지만 다음과 같은 문제가 있습니다:

- API 요청 정책(예: 타임아웃, 인증, 재시도 등)이 바뀔 때마다 컴포넌트를 수정해야 함
- 테스트하기 어려움
- 재사용이 힘듦

> API 요청 로직을 컴포넌트 밖으로 분리하여 **서비스 레이어**에 두고 관리합니다.

## 2. 서비스 레이어로 분리하기

컴포넌트 안에서 직접 API를 호출하지 말고 별도의 함수로 분리해 관리

```tsx
async function fetchCart() {
  const controller = new AbortController();

  const timeoutId = setTimeout(() => controller.abort(), 5000); //타임아웃 설정 추가

  const response = await fetch("https://api.baemin.com/cart", {
    signal: controller.signal,
  });

  clearTimeout(timeoutId);

  return response;
}
```

이렇게 하면 타임아웃 같은 정책을 추가하기 쉽고 테스트도 간편해진 것처럼 보입니다.

하지만 여전히 `fetch`의 기능이 제한적이라 확장성이 떨어집니다.

## 3. Axios 활용

`Axios`는 fetch 보다 기능이 많고 사용하기 편해 현업에서는 더 자주 사용됩니다.

```tsx
// 인스턴스 생성
export const apiRequester: AxiosInstance = axios.create({
  baseURL: "https://api.baemin.com",
  timeout: 5000,
});

// 이제 apiRequester 사용할 때마다 위 설정들이 자동 적용
export const fetchCart = (): AxiosPromise<FetchCartResponse> =>
  apiRequester.get<FetchCartResponse>("cart");
```
> **Axios 인스턴스는 기본 설정을 미리 정의해둔 axios 객체**.
> `axios.create()`로 만들 수 있고, baseURL, headers, timeout 같은 공통 설정을 한 번 정의하면 해당 인스턴스로 만든 모든 요청에 자동으로 적용된다.

여러 서버(API Entry가 다른 경우)를 사용할 때는?
```tsx
const apiRequester: AxiosInstance = axios.create(defaultConfig);

// 인스턴스 하나
const orderApiRequester: AxiosInstance = axios.create({
  baseURL: "https://api.baemin.or/",
  ...defaultConfig,
});

// 인스턴스 둘
const orderCartApiRequester: AxiosInstance = axios.create({
  baseURL: "https://cart.baemin.order/",
  ...defaultConfig,
});

```
서버별로 Axios 인스턴스를 따로 만들면 관리가 쉬워집니다.

## 4. axios 인터셉터 활용하기

인터셉터(interceptor)를 쓰면 모든 요청 또는 응답에 대해 공통 로직(예: 인증 실패 시 로그아웃)을 설정할 수 있습니다. 
빌더 패턴은 복잡한 요청 객체를 깔끔하게 구성할 수 있게 해줍니다.

### 빌더 패턴

> **복잡한 객체를 단계별로 만들어주는 설계 패턴**입니다.
> 
> - 여러 개의 설정 값이나 옵션이 필요한 객체를 만들 때
> - 생성자(constructor)만으로는 코드가 너무 길고 복잡해지기 때문에
> - 메서드 체이닝을 이용해 객체를 **"조립"**하듯 만드는 방식입니다.

### ❌ 일반 방식: 생성자에 모든 값을 다 넣는 방식
```tsx
const api = new API("GET", "/users", {
  headers: { "Content-Type": "application/json" },
  timeout: 5000,
  withCredentials: true,
  baseURL: "https://api.baemin.com",
  params: { name: "홍길동" },
});
```
해당 방식은 가독성도 떨어지고 필요한 값만 넣기 어렵습니다.

### ✅ 빌더 패턴: 메서드 체이닝으로 설정을 단계별로

```tsx
const api = APIBuilder.get("/users")
  .headers({ "Content-Type": "application/json" })
  .timeout(5000)
  .params({ name: "홍길동" })
  .withCredentials(true)
  .build();
```
어떤 값이 설정됐는지 한눈에 보이고 필요한 것만 선택적으로 설정할 수 있어 가독성과 유지보수성이 좋습니다.

- 빌더패턴 코드 예시
    - 실제 요청을 실행할 API 클래스
        
        ```tsx
        class API {
          method: "GET" | "POST" | "PUT" | "DELETE";
          url: string;
          headers?: any;
          timeout?: number;
          baseURL?: string;
          params?: any;
          data?: any;
          withCredentials?: boolean;
        
          constructor(method: string, url: string) {
            this.method = method;
            this.url = url;
          }
        
          call<T>() {
            return axios.request<T>({ ...this });
          }
        }
        
        ```
        
    - 빌더 클래스 (`APIBuilder`)
        
        ```tsx
        class APIBuilder {
          private _instance: API;
        
          constructor(method: "GET" | "POST", url: string, data?: any) {
            this._instance = new API(method, url);
            this._instance.data = data;
            this._instance.baseURL = "https://api.baemin.com";
            this._instance.headers = {
              "Content-Type": "application/json",
            };
            this._instance.timeout = 5000;
            this._instance.withCredentials = false;
          }
        
          static get(url: string) {
            return new APIBuilder("GET", url);
          }
        
          static post(url: string, data: any) {
            return new APIBuilder("POST", url, data);
          }
        
          headers(headers: any) {
            this._instance.headers = headers;
            return this;
          }
        
          timeout(timeout: number) {
            this._instance.timeout = timeout;
            return this;
          }
        
          withCredentials(flag: boolean) {
            this._instance.withCredentials = flag;
            return this;
          }
        
          params(params: any) {
            this._instance.params = params;
            return this;
          }
        
          build() {
            return this._instance;
          }
        }
        ```
        
        - `static get`, `post`는 호출 편의성을 위해 제공
        - 메서드 체이닝을 통해 원하는 설정만 조립 가능
        - 마지막에 `.build()`로 완성된 API 객체를 얻음

## 5. API 응답 타입 지정하기

실제 응답 형태는 서버마다 조금씩 다르지만 보통은 다음처럼 통일된 형태를 가집니다

```tsx
interface Response<T> {
  data: T;
  status: string;
  serverDateTime: string;
  errorCode?: string;
  errorMessage?: string;
}
```

서버가 보내는 응답(response)이 **정확히 어떤 구조인지** 알아야 **안정적으로** 화면을 만들 수 있습니다.

```tsx
interface CartItem {
  id: string;
  name: string;
  price: number;
}

interface FetchCartData {
  cartItems: CartItem[];
  totalPrice: number;
}

// API 함수
function fetchCart(): AxiosPromise<Response<FetchCartData>> {
  return apiRequester.get("/cart");
}
```

응답 타입을 지정할때 apiRequester 인스턴스에 항상 공통 응답 타입을 붙이자!는 생각이 들 수도 있습니다.

```tsx
// (❌ 이렇게 하고 싶을 수 있다)
apiRequester.get<Response<T>>("some-api");
```

그러나 이렇게 하게 되면…

- `POST`, `DELETE`, `PUT` 같은 응답 없는 API도 무조건 `Response<T>`가 있다고 가정해야 해서 `response.data.data` 같이 말도 안 되는 구조가 생김
- 실제로는 undefined인데 타입스크립트는 있다고 착각함
- 에러 처리나 로직 분기 시 실수하기 쉬움

> 요청을 보내는 도구(apiRequester)와 응답을 해석하는 책임(Response<T>)을 분리하자.

### 어떤 응답인지 확신할 수 없다면?

API 응답 중 **어떤 구조일지 확신할 수 없거나**, **사용하지 말아야 할 필드**를 표시할 때는 `unknown`은 사용합니다.

```tsx
interface response {
  data: {
    cartItems: CartItem[];
    forPass: unknown; // 서버 변경 가능성이 있어 사용 금지
  };
}
```

`unknown`으로 지정하면:

- 타입스크립트는 그 값을 그냥 쓸 수 없게 막아줍니다.
- 실수로 사용하거나 구조를 잘못 해석해서 버그가 생기는 걸 방지할 수 있습니다.

## 6. ViewModel(뷰 모델)로 API 변경에 유연하게 대응하기

서버 응답 구조가 바뀌면 프론트엔드도 그에 따라 코드를 바꿔야 해서 유지보수가 어렵습니다.

```tsx
//백엔드 API는 언제든지 바뀔 수 있습니다

// 원래 응답
{ "items": [...] }

+ // 바뀐 응답
{ "jobItems": [...] }
```

컴포넌트는 다음처럼 바꿔야 합니다.

```tsx
//setItems(response.items)
setItems(response.jobItems)
```

이럴 때 매번 컴포넌트 코드를 수정하는 대신,

**중간에서 API 응답을 가공해서 기존 코드가 바뀌지 않게 도와주는 것이 ViewModel입니다.**
> **ViewModel**은 API 응답을 프론트엔드에서 사용할 수 있도록 가공해서 표현한 데이터 모델입니다.
> ”백엔드가 보내주는 데이터(API 응답)를 프론트엔드(화면)에 **딱 필요한 형식** 으로 바꿔주는 중간 계층”

```tsx
// 서버에서 받은 원본 응답 타입
interface JobListResponse {
  positions: JobItem[];
}

// 뷰 모델 클래스: 응답을 화면에 맞게 가공
class JobList {
  readonly totalItemCount: number;
  readonly items: JobItem[];

  constructor(response: JobListResponse) {
    this.items = response.positions;
    this.totalItemCount = response.positions.length;
  }
}

// 화면에서 사용
const fetchJobList = async (): Promise<JobList> => {
  const { data } = await api.get("/jobs").call<Response<JobListResponse>>();
  return new JobList(data); // 뷰 모델로 감싸서 반환
};

// 컴포넌트에서는 뷰 모델만 알면 됨
useEffect(() => {
  fetchJobList().then((jobList) => {
    setItems(jobList.items); // 항상 items로 접근
    setTotalCount(jobList.totalItemCount);
  });
}, []);
```

이제 컴포넌트는 항상 `items`만 참조하면 되므로 서버 응답이 바뀌더라도 영향이 적습니다.

그렇다고 무조건 모든 응답에 ViewModel을 쓰는 건 오히려 복잡도만 늘립니다. 
뷰 모델은 필요한 부분만 선택적으로 사용하고 불필요하게 모든 API에 적용하지는 마세요.

## 7. 런타임 타입 검증 - Superstruct 사용하기

타입스크립트는 컴파일 단계에서 타입을 검사하기에 **실제 API 응답이 타입과 달라도 오류를 잡을 수 없습니다.**

```tsx
interface ListItem {
  id: string;
  content: string;
}
```

### 서버가 실수로 `id`를 숫자로 보내면?

타입스크립트는 **실행 중에 데이터가 실제로 그 구조인지 검사해주지 않아요.**그래서 런타임에서 타입을 검증해주는 라이브러리인 **`Superstruct`**가 있습니다. 런타임에서 실제 데이터 구조가 **우리가 기대한 타입과 맞는지 검사합니다.**

```tsx
const data = { id: 123, age: "스무살" };

assert(data, User); 
// ❌ 런타임 에러 발생:
// id는 string이어야 함
```

이렇게 하면 서버 응답이 기대한 형태와 다를 때, 런타임에서 에러를 바로 확인할 수 있습니다.

## 8. API 상태 관리 - React Query 등의 훅으로 간편하게

우리는 프론트엔드에서 데이터를 가져올 때 이런 흐름을 자주 겪습니다

1. 로딩 중인지 아닌지 표시해야 함
2. 데이터를 성공적으로 받아오면 화면에 보여줘야 함
3. 에러가 발생하면 사용자에게 알려줘야 함
4. 데이터를 다시 요청(refresh, refetch)하거나 캐싱하고 싶을 수도 있음

### 라이브러리 선택

| 방식 | 설명 | 장점 | 단점 |
| --- | --- | --- | --- |
| ❌ 컴포넌트 안에서 직접 `fetch` | `useEffect`에서 직접 요청 | 간단함 | 상태, 에러, 캐시 등 직접 다 처리해야 함 |
| ⚠️ 전역 상태 관리 (Redux, MobX) | 비동기 요청 결과를 전역 상태로 저장 | 일관성, 테스트 용이 | 복잡도 큼, 코드 양 많음 |
| ✅ 훅 기반 라이브러리 (React Query, SWR) | API 요청과 상태를 자동으로 관리해주는 도구 | 코드 간결, 자동 캐싱 | 학습 필요, 커스터마이징 제한 있음 |

### React Query란? > tanstack-query

> React Query는 **서버 상태(server state)**를 쉽게 관리할 수 있게 도와주는 라이브러리
> 

**서버 상태란?**

- 컴포넌트 안에서 직접 만든 상태(useState) → **클라이언트 상태**
- 서버에서 받아온 데이터 (예: API 응답) → **서버 상태**

React Query는 이 서버 상태를 다루는 데 최적화되어 있습니다.

| 기능 | 설명 |
| --- | --- |
| ✅ 로딩/에러/성공 상태 관리 | `isLoading`, `isError`, `data` 등을 자동으로 제공 |
| ✅ 자동 캐싱 | 같은 요청을 다시 하면 네트워크 없이도 사용 가능 |
| ✅ 자동 재시도 | 실패 시 자동 재시도 가능 (기본 설정 있음) |
| ✅ refetch | 새로고침 버튼 등을 누르면 쉽게 다시 요청 가능 |
| ✅ background 업데이트 | 화면을 보고 있어도 데이터를 백그라운드에서 갱신 가능 |

```tsx
import { useQuery } from '@tanstack/react-query';
import axios from 'axios';

const fetchProducts = () =>
  axios.get("/api/products").then(res => res.data);

function ProductList() {
  const { data, isLoading, isError } = useQuery({
    queryKey: ['products'],
    queryFn: fetchProducts,
  });

  if (isLoading) return <div>불러오는 중...</div>;
  if (isError) return <div>에러 발생</div>;

  return (
    <ul>
      {data.map(product => (
        <li key={product.id}>{product.name}</li>
      ))}
    </ul>
  );
}
```

```tsx
const queryClient = useQueryClient();

await axios.post("/api/product", newProduct);

// 캐시를 무효화 → 새 데이터 요청
queryClient.invalidateQueries({ queryKey: ['products'] });
```
