# 4장. 타입 확장하기와 좁히기

## 타입 확장
타입 확장은 기존 타입을 기반으로 새로운 타입을 정의하는 방법으로 **코드 중복을 줄이고** **명확한 타입 구조를 유지**할 수 있다.
```ts
// type 확장
type User = { name: string };
type Admin = User & { role: string };

// interface 확장
interface User {
  name: string;
}
interface Admin extends User {
  role: string;
}

const admin :Admin = {
    name: "이름",
    role: "관리자"
}
```
### 장점
- 코드 중복을 줄일 수 있다.
- 기존 타입 정의를 안전하게 확장할 수 있다.
- 변경이 필요한 부분만 추가하거나 수정할 수 있다.

## 유니온 타입
유니온 타입은 두 개 이상의 타입 중 하나를 가질 수 있도록 하는 타입이다.
```ts
type Status = "pending" | "success" | "error";
type Id = string | number;
```
> 주의!  A | B는 “A이거나 B”를 의미하지 “A이면서 B”는 아니다.

## 교차 타입
교차 타입은 여러 타입을 합쳐 모든 속성을 가진 단일 타입을 만든다.
```ts
type Contact = { phone: string };
type Address = { city: string };

// 두 타입을 합쳐 새로운 타입 생성
type Person = Contact & Address;

// 결과적으로 Person은 아래와 같음
// { phone: string; city: string; }

const person: Person = {
  phone: "010-1234-5678",
  city: "Seoul",
};
```
> 유니온 타입(|) “둘 중 하나” 와 달 교차 타입(&)은 “둘 다”를 의미한다.

### ⚠️ 주의할 점
서로 호환되지 않는 타입을 교차하면 never가 된다.
```ts
type IdType = string | number;
type Numeric = number | boolean;

// 교차 타입
type Universal = IdType & Numeric;

// 가능한 조합을 생각해보면
// 1. string & number -> ❌ 불가능
// 2. string & boolean -> ❌ 불가능
// 3. number & number -> ✅ 가능
// 4. number & boolean -> ❌ 불가능

// 따라서 Universal은 number로 좁혀집니다.
```

## extends와 교차 타입의 차이
두 방식은 비슷해 보이지만 작동 방식이 다르다.
```ts
interface DeliveryTip {
  tip: number;
}

interface Filter extends DeliveryTip {
  tip: string; // ❌ 타입 불일치 오류
}
}
// Interface 'Filter' incorrectly extends interface 'DeliveryTip'.
// Types of property 'tip' are incompatible.
// Type 'string' is not assignable to type 'number'

```
extends는 타입이 호환되어야만 확장이 가능하다.
반면 &를 사용하면 에러는 나지 않지만 결과 타입이 never가 됩니다.
```ts
type DeliveryTip = { tip: number };
type Filter = DeliveryTip & { tip: string };

// 같은 속성 이름에 서로 다른 타입이 선언되어
// 최종적으로 tip: never가 됩니다.
```

## 타입 확장의 활용
요구사항이 늘어날 때, 기존 타입에 속성을 무분별하게 추가하기보다 타입을 확장해서 관리하는 것이 더 안전합니다.
```ts
// 기본 타입
interface Menu {
  name: string;
  image: string;
}

// 특수 메뉴 타입 확장
interface SpecialMenu extends Menu {
  gif: string;
}

// 패키지 메뉴 타입 확장
interface PackageMenu extends Menu {
  text: string;
}
```
이렇게 나누면 각 타입의 목적이 명확해지고 특정 속성이 없는 객체에 잘못 접근하는 오류를 미리 방지할 수 있습니다.
> Tip: 타입 확장은 “명확한 의도”를 코드로 표현할 수 있는 가장 좋은 방법이다.

## 타입 좁히기(Type Narrowing)
타입스크립트는 조건문을 통해 타입의 범위를 점점 좁혀갈 수 있다. 이 과정을 타입 좁히기라고 한다.

### typeof 연산자
가장 기본적인 타입 가드, 주로 원시 타입(string, number, boolean)을 판별할 때 사용.
```ts
function printValue(value: string | number) {
  if (typeof value === "string") {
    console.log(value.toUpperCase()); // 문자열 메서드 사용 가능
  } else {
    console.log(value.toFixed(2));    // 숫자 메서드 사용 가능
  }
}
```
> ⚠️ typeof null이나 typeof []는 "object"이므로 복잡한 타입 검사에는 한계가 있다.


### instanceof 연산자
생성자 함수를 기준으로 객체의 타입을 판별할 때 사용.
```ts
class Dog {
  bark() {}
}
class Cat {
  meow() {}
}

function makeSound(animal: Dog | Cat) {
  if (animal instanceof Dog) {
    animal.bark();
  } else {
    animal.meow();
  }
}
```

### in 연산자
객체에 특정 속성이 존재하는지 여부를 검사.
```ts
interface BasicNoticeDialogProps {
  noticeTitle: string;
  noticeBody: string;
}

interface NoticeDialogWithCookieProps extends BasicNoticeDialogProps {
  cookieKey: string;
}

type NoticeDialogProps =
  | BasicNoticeDialogProps
  | NoticeDialogWithCookieProps;

function NoticeDialog(props: NoticeDialogProps) {
  // cookieKey 속성 존재 여부로 타입 구분
  if ("cookieKey" in props) {
    return <NoticeDialogWithCookie {...props} />;
  }
  return <NoticeDialogBase {...props} />;
}
```

### 사용자 정의 타입 가드 (is 연산자)
직접 타입 가드를 정의할 수도 있다. 이 방식은 런타임에서도 작동하므로 더욱 안전다.
```ts
// 특정 문자열이 DestinationCodeList에 존재하는지 검사
const isDestinationCode = (x: string): x is DestinationCode => {
  return destinationCodeList.includes(x);
};

// 사용 예시
function printDestination(code: string) {
  if (isDestinationCode(code)) {
    console.log("유효한 코드입니다.");
  } else {
    console.log("존재하지 않는 코드입니다.");
  }
}
```  
## 식별할 수 있는 유니온(Discriminated Union)
- 서로 비슷한 구조의 타입을 식별자 필드(판별자) 로 구분하는 방법이다.
- 필드는 보통 type, kind, code 같은 이름을 사용다.
```ts
interface NetworkError {
  type: "network";
  message: string;
  status: number;
}

interface ValidationError {
  type: "validation";
  message: string;
  field: string;
}

interface AuthError {
  type: "auth";
  message: string;
  expired: boolean;
}
// 유니온 타입으로 묶기
type AppError = NetworkError | ValidationError | AuthError;
```
이렇게 하면 타입스크립트가 각 분기에서 자동으로 타입을 좁혀 준다.
```ts
function handleError(error: AppError) {
  switch (error.type) {
    case "network":
      console.log(`네트워크 오류`);
      break;
    case "validation":
      console.log(`유효성 검사 실패`);
      break;
    case "auth":
      console.log(
        error.expired ? "만`
      );
      break;
  }
}

```

## Exhaustiveness Checking (완전한 분기 검사)
모든 경우를 처리하지 않았을 때 컴파일 타임에 경고를 주는 패턴이다.
```ts
type Status = "pending" | "success" | "error";

function assertNever(x: never): never {
  throw new Error(`처리되지 않은 케이스: ${x}`);
}

function handleStatus(status: Status) {
  if (status === "pending") {
    console.log("대기 중...");
  } else if (status === "success") {
    console.log("성공!");
  } else if (status === "error") {
    console.log("에러 발생");
  } else {
    assertNever(status); // 모든 분기 처리 확인용
  }
}
```

> 만약 "error" 케이스를 누락하면 status가 never가 아니게 되어 컴파일 에러가 발생한다.
