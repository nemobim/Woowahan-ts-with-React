# 5장 타입 활용하기

## 조건부 타입

- 조건부 타입은 어떤 조건에 따라 타입을 다르게 지정하고 싶을 때 사용
- 자바스크립트의 삼항 연산자와 비슷한 형태

### extends를 활용한 조건부 타입

```ts
T extends U ? X : Y
//T가 U 타입에 할당 가능하면 X 타입, 아니면 Y 타입
```

- 실무 예시: API 응답 타입
  요청한 경로에 따라 정확한 응답 타입을 자동으로 설정

```ts
// API 경로를 문자열 유니온으로 정의
type Endpoint = "/users" | "/products" | "/orders";

// 요청 경로에 따라 응답 타입 자동 선택
type ApiResponse<T extends Endpoint> = T extends "/users"
  ? User[]
  : T extends "/products"
  ? Product[]
  : T extends "/orders"
  ? Order[]
  : never;

// 사용 예시
async function fetchData<T extends Endpoint>(endpoint: T): Promise<ApiResponse<T>> {
  const response = await fetch(endpoint);
  return response.json();
}

const users = await fetchData("/users"); // User[] 타입으로 추론됨
const products = await fetchData("/products"); // Product[] 타입으로 추론됨
```

### 왜 조건부 타입이 필요할까?

- 타입 설정이 유니온으로만 되어있기 때문에 타입스크립트가 해당 타입에 맞는 Data 타입을 추론할 수 없음
- 인자에 따라 반환 타입을 다르게 설정하려면 조건부 타입(`extends`)이 필수!

```ts
// ❌ 타입스크립트가 정확한 타입을 추론할 수 없음
type Data = User[] | Product[] | Order[];

async function fetchData(endpoint: string): Promise<Data> {
  const response = await fetch(endpoint);
  return response.json();
}

const users = await fetchData("/users");

// users: User[] | Product[] | Order[]
// 정확한 타입을 몰라서 아래 코드에서 에러 발생
users[0].username; // ❌ 에러!
```

### infer 키워드로 타입 추론하기

- `infer`는 타입스크립트가 어떤 타입을 자동으로 추측해서 꺼내게 해줌
- extends로 조건 서술, infer로 타입을 추론 (주로 조건부 타입 안에서만 사용)

#### 실무 예시: 함수 반환 타입 추출

##### ❌ infer 없이 시도

```ts
function getUser() {
  return { id: 1, name: '홍길동', email: 'hong@example.com' };
}

// infer 없이는 반환 타입을 추출할 방법이 없음
type UserType = ???;  // 어떻게 추출하지?

// 수동으로 타입 정의해야 함 (중복 발생)
type UserType = {
  id: number;
  name: string;
  email: string;
};
```

##### ✅ infer 사용

```ts
// 함수 정의
function getUser() {
  return { id: 1, name: "홍길동", email: "hong@example.com" };
}

// 반환 타입을 수동으로 지정하는 건 번거로움
type UserType = {
  id: number;
  name: string;
  email: string;
};

// ✅ infer를 사용하면 자동으로 추출 가능
type GetReturnType<T> = T extends (...args: any[]) => infer R ? R : never;
type UserType = GetReturnType<typeof getUser>;
// UserType은 { id: number; name: string; email: string; }로 자동 추론됨
```

> infer R은 함수의 반환 타입을 추론해서 R에 넣겠다는 뜻

`getUser()` 함수가 변경되면 타입도 자동으로 바뀌기 때문에 중복 정의나 오류를 줄일 수 있다.

## 템플릿 리터럴 타입 활용

유니온 타입을 사용하여 변수 타입을 특정 문자열로 지정할 수 있다.

```ts
// 버튼 사이즈 타입 자동 생성
type Size = "small" | "medium" | "large";
type ButtonSize = `btn-${Size}`;
// 'btn-small' | 'btn-medium' | 'btn-large'
```

> **주의사항**: 템플릿 리터럴 타입의 조합이 너무 많으면 컴파일 성능이 저하될 수 있습니다.  
> 타입스크립트 컴파일러가 유니온을 추론하는 데 시간이 오래 걸리면 비효율적이라 판단해 추론을 포기하고 에러를 발생시킵니다.  
> 따라서 유니온의 조합이 너무 많은 경우 적절하게 나눠야 합니다.

## 커스텀 유틸리티 타입 활용하기

### Pick<T, K> – 필요한 속성만 뽑기

인터페이스에서 필요한 속성만 선택해 새로운 타입을 만들 때 사용.

```ts
interface ButtonProps {
  size: "small" | "medium" | "large";
  color: string;
  disabled: boolean;
  onClick: () => void;
}

// 필요한 속성만 골라서 사용
type StyledButtonProps = Pick<ButtonProps, "size" | "color" | "disabled">;
```

### PickOne – 여러 속성 중 하나만 허용

여러 속성 중 하나만 받고 싶을 때 사용

```ts
type Card = {
  card: string;
};

type Account = {
  account: string;
};

type PaymentMethod = Card | Account;

function payment(method: PaymentMethod) {
  // ...
}

payment({ card: "현대카드", account: "하나은행" }); // ❌ 둘 다 들어가도 에러가 안 남
```

유니온 타입(`Card | Account`)을 사용하면 속성이 하나씩만 할당된 경우는 허용되지만
문제는 **두 속성이 모두 포함되어도 합집합의 범주에 포함되기 때문에 타입 에러가 발생하지 않는다**

이 문제를 해결하기 위해서는?

1. **식별 가능한 유니온(Discriminated Union) 사용**

   - 객체 타입을 유니온으로 받되, 각 타입에 식별자(`type` 속성 등)를 추가하는 방법
   - 단점: 모든 타입에 식별자를 일일이 추가해야 하는 불편함이 있음

2. **PickOne 유틸리티 타입 구현**
   - 하나의 속성이 들어온 경우, 다른 속성을 옵셔널한 `undefined` 값으로 지정
   - 더 유연하고 재사용 가능한 해결책

```ts
type PickOne<T> = {
  // 내부 구현: 각 키에 대해 해당 키는 필수, 나머지는 undefined로 설정
  [P in keyof T]: Record<P, T[P]> & Partial<Record<Exclude<keyof T, P>, undefined>>;
}[keyof T];

type PaymentMethod = PickOne<{
  card: string;
  account: string;
}>;

// ✅ 하나만 사용 가능
payment({ card: "현대카드" }); // OK
payment({ account: "하나은행" }); // OK

// ❌ 둘 다 사용하면 에러
payment({ card: "현대카드", account: "하나은행" }); // 에러!
```

이 타입은 card 또는 account 중 하나만 값이 있고, 나머지는 undefined가 되도록 강제한다.

> **커스텀 유틸리티 타입 구현 팁**
>
> - 정확히 어떤 타입을 구현해야 하는지 파악하기
> - 필요한 타입을 작은 단위로 쪼개어 생각하고 단계적으로 구현하기

### nonNullable로 타입 검사 함수를 만들어 간편하게 타입 가드하기

`NonNullable`을 활용하면 `null`과 `undefined`를 제거하는 타입 가드 함수를 쉽게 만들 수 있다.

```ts
// 타입 가드 함수
function isNotNull<T>(value: T): value is NonNullable<T> {
  return value !== null && value !== undefined;
}

// 배열 필터링
const users = [{ id: 1, name: "홍길동" }, null, { id: 2, name: "김철수" }, undefined, { id: 3, name: "이영희" }];

// ✅ null, undefined 자동 제거
const validUsers = users.filter(isNotNull);
// validUsers: { id: number; name: string; }[]

validUsers.forEach((user) => {
  console.log(user.name); // ✅ 에러 없음 (null 체크 필요 없음)
});
```

> NonNullable<T>는 타입에서 null과 undefined를 제거해 준다.

## as const – 불변 객체와 정확한 타입 추론

```ts
const colors = {
  red: "#F45452",
  blue: "#1A7CFF",
}; // 일반 객체

// 이 상태에서는 colors[key]의 반환값이 string으로 추론됨
```

### as const 사용

```ts
const colors = {
  red: "#F45452",
  blue: "#1A7CFF",
} as const;

// 이제 타입스크립트는 각 값이 string이 아니라 '#F45452' 같은 **리터럴 값**임을 인식
// 객체 속성도 readonly 처리되어 변경할 수 없음

function getColor(key: keyof typeof colors) {
  return colors[key]; // '#F45452' | '#1A7CFF'로 추론
}
```

#### as const의 장점

- **자동완성 지원**: 정확한 키 값으로 자동완성 제공
- **오타 방지**: 존재하지 않는 키 사용 시 컴파일 타임에 에러 발생
- **정확한 타입 추론**: 리터럴 타입으로 정확히 추론되어 타입 안전성 향상

#### keyof와 typeof로 타입 추출

- `keyof typeof`: 객체의 키를 유니온 타입으로 추출
- `typeof`: 값의 타입을 추출

## Record 원시 타입 키 개선

### 문제: 무제한 키 허용

Category를 string으로 지정하면 모든 문자열을 키로 사용할 수 있게 되어 존재하지 않는 키에도 접근이 가능.

```ts
type Category = string;

const foodByCategory: Record<Category, string[]> = {
  한식: ["비빔밥"],
  일식: ["초밥"],
};

foodByCategory["중식"]; // ✅ 에러 없음. 하지만 undefined!
```

### 해결 1: 유니온 타입 사용

키가 제한적이고 명확할 때 사용

```ts
type Category = "한식" | "일식";

const foodByCategory: Record<Category, string[]> = {
  한식: ["제육덮밥"],
  일식: ["초밥"],
};

foodByCategory["중식"]; // ❌ 에러 발생
```

### 해결 2: Partial<Record> 사용

키가 많거나 동적일 때 사용

```ts
type Category = string;

const foodByCategory: Partial<Record<Category, string[]>> = {
  한식: ["불고기"],
  일식: ["라멘"],
};

// 접근할 때 undefined 체크 필요
const 중식 = foodByCategory["중식"]; // string[] | undefined
중식?.forEach((food) => console.log(food));
```
